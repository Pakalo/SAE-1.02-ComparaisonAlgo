/**
 * \file fonctions.cpp
 *
 * Définition des fonctions fournies.
 */
#include "fonctions.h"
#include <iostream>

 /**
  * Crée un tableau d'entiers dont tous les éléments sont choisis aléatoirement.
  *
  * Un tel tableau peut par exemple être 30968 28073 31177 2882 6140 17999 13828 20039 2310 24865.
  *
  * \param[in] N taille du tableau
  * \return le tableau initialisé
  */
std::vector<int> initTabAleat(size_t N)
{
    std::vector<int> tab(N);
    for (auto& val : tab)
        val = rand();
    return tab;
}

/**
 * Crée un tableau d'entiers presque triés. Chaque élément est quasiment à sa place définitive, échangé éventuellement d'une place.
 *
 * Un tel tableau peut par exemple être 1 3 2 4 6 5 8 7 9 10.
 *
 * \param[in] N taille du tableau
 * \return le tableau initialisé
 */
std::vector<int> initTabPresqueTri(size_t N)
{
    std::vector<int> tab(N);
    for (int i = 0; i < N; i++)
        tab[i] = i;
    for (int i = 0; i < N - 1; i++)
    {
        if (rand() % 2 == 0)
        {
            std::swap(tab[i], tab[i + 1]);
            ++i;
        }
    }
    return tab;
}

/**
 * Crée un tableau d'entiers presque triés. Seuls le premier et le deuxième élément sont échangés.
 *
 * Un tel tableau peut par exemple être 2 1 3 4 5 6 7 8 9 10.
 *
 * \param[in] N taille du tableau
 * \return le tableau initialisé
 */
std::vector<int> initTabPresqueTriDeb(size_t N)
{
    std::vector<int> tab(N);
    for (int i = 0; i < N; i++)
        tab[i] = i;
    std::swap(tab[0], tab[1]);
    return tab;
}

/**
 * Crée un tableau d'entiers presque triés. Seuls le dernier et l'avant dernier élément sont échangés.
 *
 * Un tel tableau peut par exemple être 1 2 3 4 5 6 7 8 10 9.
 *
 * \param[in] N taille du tableau
 * \return le tableau initialisé
 */
std::vector<int> initTabPresqueTriFin(size_t N)
{
    std::vector<int> tab(N);
    for (int i = 0; i < N; i++)
        tab[i] = i;
    std::swap(tab[N - 1], tab[N - 2]);
    return tab;
}

/**
 * Crée un tableau d'entiers presque triés. Seuls le premier et le dernier élément sont échangés.
 *
 * Un tel tableau peut par exemple être 10 2 3 4 5 6 7 8 9 1.
 *
 * \param[in] N taille du tableau
 * \return le tableau initialisé
 */
std::vector<int> initTabPresqueTriDebFin(size_t N)
{
    std::vector<int> tab(N);
    for (int i = 0; i < N; i++)
        tab[i] = i;
    std::swap(tab[N - 1], tab[0]);
    return tab;
}

/**
 * Vérifie qu'un tableau est correctement trié. Si le tableau est mal trié, un message d'erreur est
 * affiché sur le flux d'erreur et le programme est terminé.
 *
 * \param[in] tab Le tableau à vérifier
 * \param[in] algoName Le nom de l'algorithme de tri qui a été utilisé. Ce paramètre est optionnel.
 */
void verifTri(const std::vector<int>& tab, const std::string& algoName)
{
    const size_t taille = tab.size();
    for (size_t i = 1; i < taille; i++)
    {
        if (tab[i - 1] > tab[i])
        {
            std::cerr << "Erreur dans le tri " << algoName << (algoName.empty() ? "!" : " !") << '\n';
            exit(EXIT_FAILURE);
        }
    }
}


/*
* Tri par selection 
*/

unsigned int triSelection(std::vector<int> &tab)
{
    size_t n = tab.size(); // Initialisation de n en fonction de la taille du tableau
    unsigned int cpt = 0;
    for (int i = 0; i <= n - 2; i++) // 
    {
        int min = i;
        for (int j = i + 1; j <= n-1; j++) 
        {
            cpt++; // Compteur pour connaitre le nombre de comparaisons d’éléments
            if (tab[j] < tab[min])
            {
                min = j;
            }
        }
            if (min != i)
            {
                std::swap(tab[i], tab[min]);
            }
    }
    return cpt; // Renvoie cpt, ce qui correspond au nombre de comparaisons d’éléments
}


/*
* Tri a bulles
*/

unsigned int triBulles(std::vector<int> &tab)
{
    unsigned int cpt = 0;
    for (size_t i = 0; i < tab.size() - 1; i++) // Double boucle pour parcourir chaque élément du tableau
    {
        for (size_t j = 0; j < tab.size() - i - 1; j++)
        {
            cpt++;
            if (tab[j + 1] < tab[j])
            {
                std::swap(tab[j + 1], tab[j]);
            }
        }
    }

    verifTri(tab);
    return cpt;
}


/*
* Tri a bulles optimisé
*/
unsigned int triBullesOpti(std::vector<int> &tab)
{
    unsigned int cpt = 0;
    for (size_t i = tab.size() - 1; i > 0; i--)
    {
        bool tableau_trie = true;
        for (int j = 0; j < i; j++)
        {
            cpt++;
            if (tab[j + 1] < tab[j])
            {
                std::swap(tab[j + 1], tab[j]);
                tableau_trie = false;
            }
        }
        if (tableau_trie)
        {
            break;
        }
    }
    return cpt;
}



/*
* Tri a bulles optimisé
*/
unsigned int triPeigne(std::vector<int> &tab)
{
    size_t intervalle = tab.size();
    bool echange;
    int cpt = 0;

    while (intervalle > 1 || echange == true)
    {
        intervalle = int(intervalle / 1.3);
        if (intervalle < 1)
            intervalle = 1;

        int i = 0;
        echange = false;

        while (i < tab.size() - intervalle)
        {
            cpt++;
            if (tab[i] > tab[i + intervalle])
            {
                std::swap(tab[i], tab[i + intervalle]);
                echange = true;
            }
            i = i + 1;
        }
    }

    verifTri(tab);
    return cpt;
}



unsigned int partitionner(std::vector<int> tab, int premier, int dernier, int pivot, unsigned int& cpt)
{
    std::swap(tab[pivot], tab[dernier]);
    int j = premier;
    for (size_t i = premier; i < dernier - 1; i++)
    {
        if (tab[i] <= tab[dernier])
        {
            std::swap(tab[i], tab[j]);
            j++;
        }
        cpt++;
    }
    std::swap(tab[dernier], tab[j]);
    return j;
}


unsigned int choixPivot(std::vector<int> tab, int premier, int dernier)
{
    //Initialisation de l'aléatoire
    std::srand(std::time(nullptr));
    std::rand(); std::rand();
    //Cette fonction génére un nombre aléatoire entre deux nombres
    return static_cast<unsigned int>(static_cast<double>(dernier - premier + 1) * std::rand() / (RAND_MAX + 1)) + premier;
}


unsigned int triRapide(std::vector<int> tab, int premier, int dernier)
{
    unsigned int cpt = 0;
    if (premier < dernier)
    {
        int pivot = choixPivot(tab, premier, dernier);
        pivot = partitionner(tab, premier, dernier, pivot, cpt);
        cpt += triRapide(tab, premier, pivot - 1);
        cpt += triRapide(tab, pivot + 1, dernier);
    }
    return cpt;
}

